import pytest
import numpy as np
from ikfast_solver.ikfast_wrapper import IKFastSolver

@pytest.fixture(scope="module")
def solver():
    """Pytest fixture to initialize the solver once per test module."""
    try:
        return IKFastSolver()
    except Exception as e:
        pytest.fail(f"Failed to initialize IKFastSolver: {e}")

def test_solver_initialization(solver):
    """Tests that the solver initializes and reports the correct number of joints."""
    assert solver is not None
    assert solver.num_joints == 6  # Adjust this number based on your robot

def test_fk_ik_consistency(solver):
    """
    Tests if IK can solve for a pose generated by FK.
    This is a fundamental sanity check.
    """
    # An arbitrary set of joint angles
    joint_angles = np.deg2rad([10, 20, -30, 40, -50, 60])
    
    # 1. Use Forward Kinematics to get the end-effector pose
    fk_translation, fk_rotation = solver.compute_fk(joint_angles)
    fk_rotation_flat = fk_rotation.flatten()

    assert fk_translation is not None, "FK calculation failed"

    # 2. Use Inverse Kinematics to solve for that pose
    # We use the original angles as the initial guess to get the same solution back
    ik_solution = solver.solve_ik(fk_translation, fk_rotation_flat, joint_angles)

    assert ik_solution is not None, "IK solution not found for a valid FK pose"
    
    # 3. Check if the IK solution is very close to the original joint angles
    assert np.allclose(joint_angles, ik_solution, atol=1e-6), "FK -> IK -> FK round trip failed"

def test_batch_solver(solver):
    """Tests the high-performance batch solver on a short path."""
    # Get a starting pose from FK
    zero_angles = np.array([0.0] * solver.num_joints)
    start_pos, start_rot_flat = solver.compute_fk(zero_angles)
    start_rot_flat = start_rot_flat.flatten()
    
    # Create a simple 3-point path
    path_points = [
        start_pos,
        start_pos + np.array([0.05, 0, 0]),
        start_pos + np.array([0.05, 0.05, 0])
    ]
    
    # Prepare batch data (translation + rotation for each point)
    poses_batch = np.zeros((len(path_points), 12))
    for i, pos in enumerate(path_points):
        poses_batch[i, :3] = pos
        poses_batch[i, 3:] = start_rot_flat

    # Solve the path using the batch method
    path_solutions = solver.solve_ik_path(poses_batch, zero_angles)

    assert path_solutions is not None, "Batch solver failed to find a solution"
    assert path_solutions.shape == (len(path_points), solver.num_joints), "Batch solver returned incorrect shape"

    # Sanity check the final position
    final_fk_pos, _ = solver.compute_fk(path_solutions[-1])
    assert np.allclose(path_points[-1], final_fk_pos, atol=1e-6), "Batch solver did not arrive at target" 